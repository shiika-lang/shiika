use shiika_core::names::{method_fullname_raw, MethodFullname};
use skc_hir::MethodSignature;
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FunctionName {
    /// A function corresponding to a Shiika method.
    Unmangled(MethodFullname),
    /// A function generated by the CPS transformation.
    Generated(String),
    /// For special functions used internally
    Mangled(String),
}

impl fmt::Display for FunctionName {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FunctionName::Unmangled(name) => write!(f, "{}", name.full_name),
            FunctionName::Generated(name) => write!(f, "{}", name),
            FunctionName::Mangled(name) => write!(f, "{}", name),
        }
    }
}

impl From<MethodFullname> for FunctionName {
    fn from(name: MethodFullname) -> FunctionName {
        FunctionName::Unmangled(name)
    }
}

impl From<&MethodFullname> for FunctionName {
    fn from(name: &MethodFullname) -> FunctionName {
        FunctionName::Unmangled(name.clone())
    }
}

impl FunctionName {
    pub fn mangled(name: impl Into<String>) -> FunctionName {
        FunctionName::Mangled(name.into())
    }

    pub fn from_sig(sig: &MethodSignature) -> FunctionName {
        FunctionName::Unmangled(sig.fullname.clone())
    }

    pub fn method(class_name: impl AsRef<str>, name: impl AsRef<str>) -> FunctionName {
        FunctionName::Unmangled(method_fullname_raw(class_name.as_ref(), name.as_ref()))
    }

    pub fn generated(name: impl Into<String>) -> FunctionName {
        let name_str = name.into();
        FunctionName::Generated(name_str)
    }

    /// Returns the mangled name of the function.
    pub fn mangle(&self) -> String {
        match self {
            FunctionName::Unmangled(name) => shiika_ffi::mangle_method(&name.full_name),
            FunctionName::Generated(name) => {
                // Generated funcs are never called directly from Rust, so the name is arbitary
                name.clone()
            }
            FunctionName::Mangled(name) => name.clone(),
        }
    }

    /// Returns the method name if this function is from a Shiika method.
    pub fn method_name(&self) -> Option<&MethodFullname> {
        match self {
            FunctionName::Unmangled(name) => Some(name),
            _ => None,
        }
    }
}
